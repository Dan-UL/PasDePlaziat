---
output:
  pdf_document:
    df_print: kable
    includes:
      before_body: "TP-title.tex"
      in_header: "preamble-latex.tex"
---  
\centering  

\clearpage  
  
\tableofcontents   

\justify  
\clearpage  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

 
 
```{r paquetages, message=FALSE, eval=TRUE, include=FALSE, echo = FALSE}
### Liste des paquetages
liste.paquetage <- c("ggplot2", "maps", "mice", "graphics", "gridExtra")

### On installe les paquetages de la liste qu'on a pas déjà
inst <- liste.paquetage %in% installed.packages()
if(length(liste.paquetage[!inst]) > 0) install.packages(liste.paquetage[!inst])

lapply(liste.paquetage, require, character.only = TRUE)
library(ggplot2)
library(maps)
library(mice)
library(graphics)
library(gridExtra) 
```

```{r data import, echo = F}
data.raw <- read.csv("Flood_California.csv")
```

# Introduction

Le jeu de données utilisé est une base de données de réclamations d'assurance faites, par contrat, à la suite d'inondations aux États-Unis par FEMA. Étant donné que le jeu de données est trop volumineux, l'analyse se fera seulement sur l'état de la Californie. La variable réponse est le montant total payé par réclamation en dollar USD (totalAmount). Cette variable est obtenue en additionnant le montant payé sur la réclamation du bâtiment (amountPaidOnBuildingClaim), le montant payé sur la réclamation des biens (amountPaidOnContentsCaim) et le montant payé sur l’augmentation des coûts de la conformité (amountPaidOnIncreasedCostOfComplianceClaim).

<!-- FEMA exposition -->

# Sélection des variables

```{r data setup 1, echo = F}
## Retirer les variables inutiles
data.rm <- data.raw[, c(1, 3, 4, 5, 6, 13, 14, 15, 16, 21, 25, 27, 28, 33, 39, 41)]
data <- data.raw[, -c(1, 3, 4, 5, 6, 13, 14, 15, 16, 21, 25, 27, 28, 33, 39, 41)]
```

La première étape du travail a consisté à réduire la dimension du jeu de données. En effet, celui-ci est constitué de 41 variables, dont une bonne partie n'étant pas utiles dans le contecte de l'analyse des montants de réclamation. 

Sans effectuer aucune analyse statistique, nous avons jugé adéquat de retirer plusieurs variables du modèle, notamment, toutes les variables contenant beaucoup de valeurs manquantes, comme baseFloodElevation, basementEnclosureCrawlspace, elevationCertificateIndicator, elevationDifference, rateMethod et lowestAdjacentGrade. Ces variables sont aussi toutes issues de l'évaluation de quelques uns des bâtiments assurés, alors que plusieurs autres variables telles que numberOfFloorsInTheInsuredBuilding, originalConstructionDate ou encore lowestFloorElevation  auront un impact probablement plus marqué sur le modèle sans devoir nécessiter un travail ardu et approximatif d'estimation d'une grande quantité de données manquantes.

Nous avons aussi pris la décision d'enlever les variables temporelles à l'exception de la date de construction du bâtiment (originalConstructionDate) et la date du sinistre (dateOfLoss), puisqu'elles sont les seules variables temporelles pertinentes à notre analyse.


# Sélection des observations

Les sujets d'intérêts sont, pour se remémoriser, les polices d'assurances couvrant le risque d'inondation pour des bâtiments de l'État de la Californie. Il est donc important de s'assurer que les données proviennent uniquement de la Californie. On peut effectuer cette sélection grâce aux données de coordonnées (latitude et logitude) ainsi qu'avec les code de comtés disponibles dans le jeu de données. 


```{r USA map 1,  echo = F, warning=F}
## Carte des états-unis contanant toutes les données
mapUSA <- borders(database = "state", 
                  colour="gray50", fill="white")
ggplot(data = data, aes(x = longitude, y = latitude)) +
    mapUSA + geom_point(alpha = .4)+
  labs(title = "Validation de la localication des polices d'assurance",y = "Latitude", x = "Longitude")+
  theme_minimal()
```
Grâce à cette carte, on peut facilement voir que certaines données ne sont visiblement pas situées en Californie. Ces observations sont retirées du jeu de données.

```{r Non-californian removal, echo = F}
# Retirer les lignes n'étant pas localisées en Californie
data <- data[!is.na(data$longitude),]
data <- data[data$longitude <= -110,]
```

Ensuite, en observant les codes de comtés des observations restantes, on peut réaliser que trois observations arborent le code "32031", qui appartient au comté de Washoe au Nevada. Ces trois données sont donc retirées du jeu de données.

```{r 32031 removal, echo = F}
# Retirer les lignes n'étant pas localisées en Californie
data <- data[data$countyCode != 32031,]
```

Voici à quoi ressemble la distribution des données restantes sur la carte de la Californie.

```{r geolocalisation, echo = F, warning=F}
mapCalifornia <- borders(database = "county", region = "california",
                  colour="gray50", fill="white")
ggplot(data = data, aes(x = longitude, y = latitude )) +
    mapCalifornia + geom_point(alpha = .4)  +
  labs(title = "Polices d'assurance en Californie",y = "Latitude", x = "Longitude")+
  theme_minimal()
```

# Imputation des données manquantes

Le jeu de données comporte plusieurs données manquantes réparties dans multiples variables explicatives. Explorons le patron de non réponse.

```{r initial md pattern, echo = F}
x <- md.pattern(data, rotate.names = T)
```
Attaquons la variable communityRatingDiscount en premier. En effet, celle-ci indique le niveau auquel la police d'assurance a droit à un rabais sur sa prime en fonction de de la zone d'inondation dans laquelle le bâtiment se retouve. La cote est sur une échelle de 1 à 10, du plus gros rabais pour la classe 1 à l'absence de rabais. La façon la plus intuitive que nous avons pu trouver de gérer les données manquante est de leur attribuer arbitrairement la classe 10, puisque selon l'organisme qui publie ces données, les données manquantes ne participent tout simplement pas au programme de primes.

```{r communityRatingDiscount, echo = F}
# Attribution de la classe 10 aux données manquantes de la variable communityRatingSystemDiscount (Les valeurs manquantes sont dans des zones qui ne participent pas au système de rabais, et la classe 10 indique les zones n'ayant pas droit à un rabais.)
data$communityRatingSystemDiscount[is.na(data$communityRatingSystemDiscount)] <- 10
```

Ensuite, la variable du nombre d'étages du bâtiment (variable numberOfFloorsInTheInsuredBuilding) arborait un certain nombre de données manquantes pouvant être imputées. Nous avons commencé par reclassifier celle du type d'occupartion du bâtiment (occupancyType) en trois classes plus intuitives selon les descriptions des 14 classes offertes par le publicateur des données. Une de ces 14 classes n'avait aucune description, nous l'avons attribué à la classe ayant la proportion du nombre d'étages la plus semblable, qui est la classe 2.

* Niveau 1: Résidences familiales
* Niveau 2: Copropriétés résidentielles
* Niveau 3: Non-résidentiel

En effet, nous avons identifié la variable du type d'occupation intuitivement comme une variable intimement corrélée avec le nombre d'étages du bâtiment, car elle donnc des indices sur la nature du bâtiment. Elle servira donc à l'imputation des données du nombre d'étages.

Nous avons donc imputé les données à l'aide d'un modèle accordant le nombre d'étages aléatoirement en fonction de la distribution du nombre d'étages à l'intérieur d'une même classe d'occupation du bâtiment.

```{r occupancyType, echo = F}
# Reclassifiaction de la variable occupancyType
data$occupancyType <- as.factor(data$occupancyType)
levels(data$occupancyType) <- c("1", "2", "2", "3", "1", "1", "2", "2", "1", "2", "2", "3", "3", "3")

# Éliminaion des données manquant la variable occupancyType
data <- data[-which(is.na(data$occupancyType)),]

# Imputation des données manquantes de la variable numberOfFloorsInTheInsuredBuilding de facon aléatoire selon la proportion de la variable occupancyType de type 1

prop.occ1 <- cumsum(prop.table(table(data$numberOfFloorsInTheInsuredBuilding[which(data$occupancyType == 1)])))

imp.occ1 <- data$numberOfFloorsInTheInsuredBuilding[which(is.na(data$numberOfFloorsInTheInsuredBuilding))]
set.seed(6969)
RNG <- runif(length(imp.occ1))
for(i in 1:length(imp.occ1)){
  if(RNG[1] <= prop.occ1[1])
    imp.occ1[i] <- 1
if(RNG[i] > prop.occ1[1] & RNG[i] <= prop.occ1[2])
    imp.occ1[i] <- 2
  if(RNG[i] > prop.occ1[2] & RNG[i] <= prop.occ1[3])
    imp.occ1[i] <- 3
if(RNG[i] > prop.occ1[3] & RNG[i] <= prop.occ1[4])
    imp.occ1[i] <- 4
  if(RNG[i] > prop.occ1[4] & RNG[i] <= prop.occ1[5])
    imp.occ1[i] <- 5
  if(RNG[i] > prop.occ1[5])
    imp.occ1[i] <- 6
}

data$numberOfFloorsInTheInsuredBuilding[which(is.na(data$numberOfFloorsInTheInsuredBuilding))] <- imp.occ1
```

La dernière variable à imputer est l'indicateur du bâtiment étant un condo ou non. On utilise tout simplement notre variable du type d'occupation du bâtiment; si l'observation est dans la catégorie 1, on lui impute une valeur de "1" et une valeur de "0" dans le cas contraire.

```{r condoz, echo = F}
#Gestion des donnees manquantes de la variables condoIndicator

condoz <- numeric(length(data$condominiumIndicator))
for(i in 1:length(condoz)) {
  if (data$condominiumIndicator[i] == "N")
    condoz[i] <- 0
  if (data$condominiumIndicator[i] == "A" |
      data$condominiumIndicator[i] == "L" |
      data$condominiumIndicator[i] == "U" |
      data$condominiumIndicator[i] == "H")
    condoz[i] <- 1
  if (data$condominiumIndicator[i] == "")
    condoz[i] <- NA
}

data$condominiumIndicator <- condoz

xdf <- data[which(is.na(data$condominiumIndicator)), ]

xdg <- numeric(nrow(xdf))
for(i in 1:nrow(xdf)){
  if(xdf$occupancyType[i] == "2")
    xdg[i] <- 1
  else
    xdg[i] <- 0
}
data$condominiumIndicator[which(is.na(data$condominiumIndicator))] <- xdg
data$condominiumIndicator <- as.factor(data$condominiumIndicator)

```

Observons à nouveau notre patron de non réponse. 

```{r final md pattern, echo = F}
x <- md.pattern(data, rotate.names = T)
```

On remarque que les données manquantes restantes se retrouvent dans les trois variables contenant les montants de réclamation. Nous gèrerons ceci dans la prochaine section. 

# Création de la nouvelle variable réponse

Dans le jeu de données se retrouvent trois colonnes contenant des informations sur les montants de prestations payés en lien avec le bâtiment (amountPaidOnBuildingClaim), les biens (amountPaidOnContentsClaim) et l'augmentation des coûts en lien avec la conformité (amountPaidOnIncreasedCostOfComplianceClaim). 

On suppose dans ce cas que les données manquantes peuvent tout simplement se faire attribuer la valeur de 0, indiquant l'absence de paiement dans cette catégorie. Ensuite, nous combinons ces trois variables en créant une nouvelle variable du paiement de prestation total versé au détenteur de police. Celle-ci sera la variable réponse du modèle.

```{r total amount paid, echo = F}
# Combiner les variables réponses (totalAmount)
data$amountPaidOnBuildingClaim[is.na(data$amountPaidOnBuildingClaim)] <- 0
data$amountPaidOnBuildingClaim <-
  abs(data$amountPaidOnBuildingClaim)
data$amountPaidOnContentsClaim[is.na(data$amountPaidOnContentsClaim)] <-0
data$amountPaidOnContentsClaim <-
  abs(data$amountPaidOnContentsClaim)
data$amountPaidOnIncreasedCostOfComplianceClaim[is.na(data$amountPaidOnIncreasedCostOfComplianceClaim)] <- 0
data$amountPaidOnIncreasedCostOfComplianceClaim <-
  abs(data$amountPaidOnIncreasedCostOfComplianceClaim)
data$totalAmount <- apply(data[, 17:19], 1, sum)
data <- data[, -c(17, 18, 19)]
```


```{r final data setup, echo = F}
# Imputation par régression linéaire des codes de régions (countyCode)
mod.county <- lm(countyCode ~ latitude + longitude, data = data)
pred.county <- predict(mod.county, newdata = data[is.na(data$countyCode),], type = "response")
data$countyCode[is.na(data$countyCode)] <- pred.county

# Changement du type de variable pour les dates
data$dateOfLoss <- as.Date(data$dateOfLoss)

#sum(format(data$dateOfLoss, "%Y") != data$yearOfLoss)
# La variable YearofLoss peut être summprimée
data <- subset(data, select = -c(yearOfLoss))
```


# Analyse exploratoire des données

Puisque nous voulons étudier les réclamations causés par un sinistre, nous allons retenir les montants supérieurs à 10$. Ce seuil a été choisi car, logiquement les réclamations en dessous de ce montant devraient être quasi inexistantes. 

## Variables non pertinentes

```{r, echo=F}
# Transformations des variables en classes appropriées

data$agricultureStructureIndicator <- factor(data$agricultureStructureIndicator)

data$communityRatingSystemDiscount <- factor(data$communityRatingSystemDiscount)

data$elevatedBuildingIndicator <- factor(data$elevatedBuildingIndicator)

data$houseWorship <- factor(data$houseWorship)

data$locationOfContents <- factor(data$locationOfContents)

data$numberOfFloorsInTheInsuredBuilding <- factor(data$numberOfFloorsInTheInsuredBuilding)

data$nonProfitIndicator <- factor(data$nonProfitIndicator)

data$occupancyType <- factor(data$occupancyType)

data$smallBusinessIndicatorBuilding <- factor(data$smallBusinessIndicatorBuilding)

data$primaryResidence <- factor(data$primaryResidence)

# On est interessé au montant de la réclamation s'il y a 
data <- subset(data, data$totalAmount > 10 )
```

```{r, echo = F}
p1 <- ggplot(data, aes(x = agricultureStructureIndicator, fill = agricultureStructureIndicator))+
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0, size = 2)+
  labs(y = "Quantité", x = "Est une structure agricole", title = "Répartition des variables jugées non pertinentes")+
  theme(legend.position = "none")   

p2 <- ggplot(data, aes(x = houseWorship, fill = houseWorship))+  
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0, size = 2)+
  labs(y = "Quantité", x = "Est une structure religieuse", title = " ")+
  theme(legend.position = "none")

p3 <- ggplot(data, aes(x = smallBusinessIndicatorBuilding, fill = smallBusinessIndicatorBuilding))+
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0,size = 2)+
  labs(y = "Quantité", x = "Est une petite entreprise",title = " ")+
  theme(legend.position = "none")

p4 <- ggplot(data, aes(x = nonProfitIndicator, fill = nonProfitIndicator))+
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0, size = 2)+
  labs(y = "Quantité", x = "Est un organisme à but non lucratif",title = " ")+
  theme(legend.position = "none")

p5 <- ggplot(data, aes(x = factor(policyCount), fill = factor(policyCount)))+
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0, size = 2)+
  labs(y = "Quantité", x = "Nombre de police",title = " ")+
  theme(legend.position = "none")

grid.arrange(p1, p2, p3, p4, p5 , ncol = 3)

data <- subset(data, select = -c(agricultureStructureIndicator, houseWorship, smallBusinessIndicatorBuilding, nonProfitIndicator, policyCount, state, countyCode,amountPaidOnBuildingClaim))
```


Tel qu'on peut le voir dans les graphiques précédants, les cinq variables indicatices (smallBusinessIndicatorBuilding, agricultureStructureIndicator, houseWorship, policyCount et nonProfitIndicator) sont trop peu fréquentes pour être significatives, ce qui indique que les données conservées sont quasi homogènes par rapport à ces variables. Nous pouvons donc les retirer.

## Variable *condominiumIndicator*

```{r, echo=F, warning = F}
ggplot(data, aes(x = condominiumIndicator, y = log(totalAmount), col = condominiumIndicator))+
  geom_boxplot()+
  theme_minimal()+
  labs( x = "Est un condominium",y = "Montant total (échelle log)", title = "Montant total en fonction de condominiumIndicator")+
  theme(legend.position = "none")

```

```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  Condominium = c(min(data$totalAmount[data$condominiumIndicator == 1]),
                  max(data$totalAmount[data$condominiumIndicator == 1]), 
                  median(data$totalAmount[data$condominiumIndicator == 1]),
                  mean(data$totalAmount[data$condominiumIndicator == 1]),
                  sd(data$totalAmount[data$condominiumIndicator == 1])),
  
  Autre = c(min(data$totalAmount[data$condominiumIndicator == 0]),
            max(data$totalAmount[data$condominiumIndicator == 0]),
            median(data$totalAmount[data$condominiumIndicator == 0]),
            mean(data$totalAmount[data$condominiumIndicator == 0]),
            sd(data$totalAmount[data$condominiumIndicator == 0]))
  ))
  
colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques sur totalAmount selon condominiumIndicator")
```



Cette variable est indicatrice, elle prendre une valeur de 1 si l’habitation est un condominium, 0 sinon. Pour faciliter la visualisation, une transformation logarithmique est effectuée sur le montant total, cette échelle sera aussi utilisée pour de futurs graphiques. Comme on peut le voir avec le tableau et le graphique, lorsqu'il y a une réclamation dans un condominium elles tend à être en moyenne plus élevée.




## Variable *communityRatingSystemDiscount*

```{r, echo=F}
p1 <- ggplot(data, aes(x = communityRatingSystemDiscount, y = log(totalAmount), col = communityRatingSystemDiscount ))+
  geom_boxplot()+
  labs( title = "Montant total en fonction de communityRatingSystemDiscount", subtitle = "Avant le regroupement",y = "Montant total (échelle log)", x = "Type de rabais", col = "")+
  theme_minimal()+
  coord_flip()+
  theme(legend.position = "none")


levels(data$communityRatingSystemDiscount) <- c("4","4","3","3","2","2","2","2","1")

p2 <- ggplot(data, aes(x = communityRatingSystemDiscount, y = log(totalAmount), col = communityRatingSystemDiscount ))+
  geom_boxplot()+
  labs(subtitle = "Après le regroupement",y = "Montant total (échelle log)", x = "Type de rabais", col = "")+
  theme_minimal()+
  coord_flip()+
  theme(legend.position = "none")

grid.arrange(p1, p2, ncol = 1)
```

```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  Aucun = c(min(data$totalAmount[data$communityRatingSystemDiscount == 1]),
                  max(data$totalAmount[data$communityRatingSystemDiscount == 1]), 
                  median(data$totalAmount[data$communityRatingSystemDiscount == 1]),
                  mean(data$totalAmount[data$communityRatingSystemDiscount == 1]),
                  sd(data$totalAmount[data$communityRatingSystemDiscount == 1])),
  
  "5% - 20%" = c(min(data$totalAmount[data$communityRatingSystemDiscount == 2]),
            max(data$totalAmount[data$communityRatingSystemDiscount == 2]),
            median(data$totalAmount[data$communityRatingSystemDiscount == 2]),
            mean(data$totalAmount[data$communityRatingSystemDiscount == 2]),
            sd(data$totalAmount[data$communityRatingSystemDiscount == 2])),
  
  "25% - 35%" = c(min(data$totalAmount[data$communityRatingSystemDiscount == 3]),
            max(data$totalAmount[data$communityRatingSystemDiscount == 3]),
            median(data$totalAmount[data$communityRatingSystemDiscount == 3]),
            mean(data$totalAmount[data$communityRatingSystemDiscount == 3]),
            sd(data$totalAmount[data$communityRatingSystemDiscount == 3])),
    
   "40% et plus" = c(min(data$totalAmount[data$communityRatingSystemDiscount == 4]),
            max(data$totalAmount[data$communityRatingSystemDiscount == 4]),
            median(data$totalAmount[data$communityRatingSystemDiscount == 4]),
            mean(data$totalAmount[data$communityRatingSystemDiscount == 4]),
            sd(data$totalAmount[data$communityRatingSystemDiscount == 4]))
  ))
  


colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques sur totalAmount selon communityRatingSystemDiscount")
```

Cette variable représente le remboursement par le gouvernement pour les individus éligibles, donc à faible revenu et situés dans une zone à risque. Par conséquent un grand remboursement indique un plus grand risque d'inondation.

On remarque qu'il y a un trop grand nombre de catégories. Pour cette raison, elles sont réunies en quatres niveaux:

* Niveau 1 : Aucun
* Niveau 2 : 5% - 20%
* Niveau 3 : 25% - 35%
* Niveau 4 : 40% et plus

Comme le  montre le graphique et le tableau plus le remboursement est élevé, plus les réclamations augmentent.


## Variable *dateOfLoss*



```{r, echo=F}
ggplot(data, aes(x = dateOfLoss, y = totalAmount))+
  geom_point(alpha = 0.4)+
  theme_minimal()+
  labs(x = "Date d'infiltration d'eau", y = "Montant total", title = "Montant de la réclamation en fonction de la date" )
```

Cette variable temporelle, au jours près, indique la date où s’est produit l’infiltration d’eau dans le bâtiment. La période commence en 1968 et se termine en 2021.

## Variable *elevatedBuildingIndicator*

```{r, echo=F}
ggplot(data, aes(x = elevatedBuildingIndicator, y = log(totalAmount), col = elevatedBuildingIndicator))+
  geom_boxplot()+
  theme_minimal()+
  labs( x = "Le bâtiment est élevé",y = "Montant total (échelle log)", title = "Montant de la réclamation selon l'élévation")+
  theme(legend.position = "none")
```

```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  "Le bâtiment est élevé" = c(min(data$totalAmount[data$elevatedBuildingIndicator == 1]),
                  max(data$totalAmount[data$elevatedBuildingIndicator == 1]), 
                  median(data$totalAmount[data$elevatedBuildingIndicator == 1]),
                  mean(data$totalAmount[data$elevatedBuildingIndicator == 1]),
                  sd(data$totalAmount[data$elevatedBuildingIndicator == 1])),
  
  "Ne l'est pas"  = c(min(data$totalAmount[data$elevatedBuildingIndicator == 0]),
            max(data$totalAmount[data$elevatedBuildingIndicator == 0]),
            median(data$totalAmount[data$elevatedBuildingIndicator == 0]),
            mean(data$totalAmount[data$elevatedBuildingIndicator == 0]),
            sd(data$totalAmount[data$elevatedBuildingIndicator == 0]))
  ))
  


colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques sur totalAmount selon elevatedBuildingIndicator")
```

Cette variable est indicatrice, elle prend une valeur de 1 si le bâtiment est élevé, 0 sinon. Un bâtiment est considéré élevé si le plancher le plus bas est au dessus du niveau du sol.

Selon le tableau et le graphique, nous observons des montants plus grands de réclamation pour les bâtiments élevés. En effet, si le le bâtiment est élevé et qu'il y a une réclamation, nous en déduisons que l'inondation était plus catastrophique, donc des dégâts plus importants.

## Variables *latitude* et *longitude*

```{r , echo = F}

mapCalifornia <- borders(database = "county", region = "california",
                  colour="gray50", fill="#D1D0CE")
ggplot(data = data, aes(x = longitude, y = latitude, col= log(totalAmount))) +
    mapCalifornia + geom_point(alpha = .6) + scale_color_gradientn(colors = c("#00FFFF", "#FFFDD0", "#FF0000"))+
  theme_minimal()+
  labs(x= "Longitude", y="Latitude", title = "Réclamation en fonction de la localisation", col ="Montant total (échelle log)")
  



```

Grâce au graphique précédent, nous observons que la majorité des réclamations sont situés aux alentours des grands centres urbains. Pour en nommer quelques uns: Sacramento, Los Angeles, San Fransisco.

## Variable *locationOfContents*


```{r, echo=F}
p1 <- ggplot(data, aes(x = locationOfContents))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)), nudge_y =250, size = 4)+
  theme_minimal()+
  labs(title = "Répartition de la variable locationOfContents", subtitle = "Avant le regroupement",y = "Quantité", x = "Localisation du contenu")+ coord_flip()
  
p2 <- ggplot(data, aes(x = locationOfContents, y = log(totalAmount), col = locationOfContents))+
  geom_boxplot()+
  theme_minimal()+
  labs(title = "Montant de la réclamation selon locationOfContents", subtitle = "Avant le regroupement",y = "Montant total (échelle log)", x = "Localisation du contenu")+
  coord_flip()+
  theme(legend.position = "none")


grid.arrange(p1, p2, ncol = 1)
```



```{r, echo = F}
levels(data$locationOfContents) <- c("1","1","1","2","3","3","2","1")

p3 <- ggplot(data, aes(x = locationOfContents))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)),nudge_y = 250, size = 4)+
  theme_minimal()+
  labs(title = "Répartition de la variable locationOfContents", subtitle = "Après le regroupement",y = "Quantité", x = "Localisation du contenu")+
  theme(legend.position = "none")+ 
  coord_flip()
  
p4 <- ggplot(data, aes(x = locationOfContents, y = log(totalAmount), col = locationOfContents))+
  geom_boxplot()+
  theme_minimal()+
  labs(title = "Montant de la réclamation selon locationOfContents", subtitle = "Après le regroupement",y = "Montant total (échelle log)", x = "Localisation du contenu")+
  coord_flip()+
  theme(legend.position = "none")

grid.arrange(p3, p4, ncol = 1)
```

```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  "Sous-sol" = c(min(data$totalAmount[data$locationOfContents == 1]),
                  max(data$totalAmount[data$locationOfContents == 1]), 
                  median(data$totalAmount[data$locationOfContents == 1]),
                  mean(data$totalAmount[data$locationOfContents == 1]),
                  sd(data$totalAmount[data$locationOfContents == 1])),
  
  "Premier étage seulement" = c(min(data$totalAmount[data$locationOfContents == 2]),
            max(data$totalAmount[data$locationOfContents == 2]),
            median(data$totalAmount[data$locationOfContents == 2]),
            mean(data$totalAmount[data$locationOfContents == 2]),
            sd(data$totalAmount[data$locationOfContents == 2])),
  
  "Premier étage et plus" = c(min(data$totalAmount[data$locationOfContents == 3]),
            max(data$totalAmount[data$locationOfContents == 3]),
            median(data$totalAmount[data$locationOfContents == 3]),
            mean(data$totalAmount[data$locationOfContents == 3]),
            sd(data$totalAmount[data$locationOfContents == 3]))
    
  ))
  


colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques sur totalAmount selon locationOfContents")
```

Cette variable catégoritielle indique où se trouve le contenu endomagé dans le bâtiment assuré.

On remarque pour la variable locationOfContents, qu'il y a plusieurs catégories ne comportant qu'un faible nombre d'observations. Certaines seront donc combinées selon leur nombre d'étage pour former les nouvelles catégories suivantes:

* Niveau 1 : Sous-sol
* Niveau 2 : Premier étage seulement
* Niveau 3 : Premier étage et plus

Comme nous pouvons l'observer dans le graphique à boîtes à moustache après le regroupement, plus le niveau d'eau monte dans la maison plus les réclamations sont importantes, puisque plus d'objets sont affectés.



## Variable *lowestFloorElevation*  

```{r, echo = F, warning = F}
data.x <- subset(data, data$lowestFloorElevation < 2000)
data.x <- subset(data.x,data$totalAmount < 400000)

ggplot(data.x, aes(x = lowestFloorElevation, y = totalAmount))+
  geom_point(alpha = 0.4)+
  theme_minimal()+
  labs(x = "Hauteur du plus bas étage (Pieds)", y = "Montant total", title = "Montant des réclamations en fonction de l'élévation de plus bas étage" )
  
```

```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  "Hauteur (en pieds)" = c(min(data$lowestFloorElevation),
            max(data$lowestFloorElevation),
            median(data$lowestFloorElevation),
            mean(data$lowestFloorElevation),
            sd(data$lowestFloorElevation))
  ))
  


colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques de lowestFloorElevation")
```

Cette variable représente la hauteur du plus bas étage de l'habitation, en pieds, où il y a eu réclamation. Tel qu'observer sur le graphique les réclamation sont généralements plus élevés lorsque la hauteur du plus bas étage est petite. De plus, dans le tableau, on remarque que la moyenne est de 8.29717 pieds. Alors, les habitations sont habituellement près du niveau du sol.


## Variable *numberOfFloorsInTheInsuredBuilding*


```{r, echo=F}
p1 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)), nudge_y =250, size = 4)+
  theme_minimal()+
  labs(title = "Répartition de la variable numberOfFloorsInTheInsuredBuilding", subtitle = "Avant le regroupement",y = "Quantité", x = "Nombre d'étages")+ coord_flip()
  
p2 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding, y = log(totalAmount), col = numberOfFloorsInTheInsuredBuilding))+
  geom_boxplot()+
  theme_minimal()+
  labs(title = "Montant de la réclamation selon numberOfFloorsInTheInsuredBuilding", subtitle = "Avant le regroupement",y = "Montant total (échelle log)", x = "Nombre d'étages")+
  coord_flip()+
  theme(legend.position = "none")


grid.arrange(p1, p2, ncol = 1)
```

```{r, echo = F}
levels(data$numberOfFloorsInTheInsuredBuilding) <- c("1","2","3","2","1","3")

p3 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)),nudge_y = 250, size = 4)+
  theme_minimal()+
  labs(title = "Répartition de la variable numberOfFloorsInTheInsuredBuilding", subtitle = "Après le regroupement",y = "Quantité", x = "Nombre d'étages")+
  theme(legend.position = "none")+ 
  coord_flip()
  
p4 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding, y = log(totalAmount), col = numberOfFloorsInTheInsuredBuilding))+
  geom_boxplot()+
  theme_minimal()+
  labs(title = "Montant de la réclamation selon numberOfFloorsInTheInsuredBuilding", subtitle = "Après le regroupement",y = "Montant total (échelle log)", x = "Nombre d'étages")+
  coord_flip()+
  theme(legend.position = "none")

grid.arrange(p3, p4, ncol = 1)
```

```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  "1 étage" = c(min(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 1]),
                  max(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 1]), 
                  median(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 1]),
                  mean(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 1]),
                  sd(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 1])),
  
  "2 étages" = c(min(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 2]),
            max(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 2]),
            median(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 2]),
            mean(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 2]),
            sd(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 2])),
  
  "3 étages et plus" = c(min(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 3]),
            max(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 3]),
            median(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 3]),
            mean(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 3]),
            sd(data$totalAmount[data$numberOfFloorsInTheInsuredBuilding == 3]))
    
  ))
  


colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques sur totalAmount selon numberOfFloorsInTheInsuredBuilding")
```



Cette variabe indique le nombre d'étage de l'habitation assuré. Elle comportait 6 catégories d'habitation, nous avons conservé les trois premiers niveaux, et nous avons combinés les trois dernières selon leur nombre d'étages. Nous avons ainsi obtenu les niveaux suivants :

* Niveau 1 : 1 étage
* Niveau 2 : 2 étages
* Niveau 3 : 3 étages et plus

Nous observons que la majorité des dommages sont concentés sur les maisons à 1 ou 2 étages.







## Variable *occupancyType*

```{r, echo = F}
levels(data$occupancyType) <- c("2","1","3")
data$occupancyType <- factor(data$occupancyType, levels = c( "1", "2", "3"))

ggplot(data, aes(x=occupancyType, y= log(totalAmount), col = occupancyType))+
  geom_boxplot()+
  theme_minimal()+
  labs(title = "Montant des réclamations en fonction du type de résidence",y = "Montant totale (échelle log)", x = "Type de résidence")+
  theme(legend.position = "none")

```

```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  "Résidences familiales" = c(min(data$totalAmount[data$occupancyType == 1]),
                  max(data$totalAmount[data$occupancyType == 1]), 
                  median(data$totalAmount[data$occupancyType == 1]),
                  mean(data$totalAmount[data$occupancyType == 1]),
                  sd(data$totalAmount[data$occupancyType == 1])),
  
  "Copropriétés résidentielles" = c(min(data$totalAmount[data$occupancyType == 2]),
            max(data$totalAmount[data$occupancyType == 2]),
            median(data$totalAmount[data$occupancyType == 2]),
            mean(data$totalAmount[data$occupancyType == 2]),
            sd(data$totalAmount[data$occupancyType == 2])),
  
  "Non-résidentiel" = c(min(data$totalAmount[data$occupancyType == 3]),
            max(data$totalAmount[data$occupancyType == 3]),
            median(data$totalAmount[data$occupancyType == 3]),
            mean(data$totalAmount[data$occupancyType == 3]),
            sd(data$totalAmount[data$occupancyType == 3]))
    
  ))
  


colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques sur totalAmount selon occupancyType")
```

Cette variable catégorielle indique le type de résidence du bâtiment.

* Niveau 1: Résidences familiales
* Niveau 2: Copropriétés résidentielles
* Niveau 3: Non-résidentiel

Tel qu'observé dans le graphique et la table de statistiques, les résidences familliales ont en général des dommages moins importants que les copropriétés et il évident que les édifices non résidentiels ont des réclamations plus élevées en cas de sinistres.


## Variable *totalCoverage*

```{r, echo = F}
data$totalCoverage <- data$totalBuildingInsuranceCoverage + data$totalContentsInsuranceCoverage


ggplot(data, aes(x = totalCoverage, y = totalAmount))+
  geom_point(alpha = 0.4)+
  theme_minimal()+
  labs(x = "Montant de la couverture d'assurance", y = "Montant total", title = "Montant des réclamations en fonction de la couverture d'assurance" )

data <- subset(data , select = -c(totalBuildingInsuranceCoverage, totalContentsInsuranceCoverage))

```


Dans le jeu de données, les montants de couverture (totalBuildingInsuranceCoverage)  pour le bâtiment et pour les biens personnels (totalContentsInsuranceCoverage) étaient séparés, nous avons jugés plus logique de combiner les deux variables en une seule (totalCoverage), puisque nous avions déjà réunis les montants des réclamations.

Nous remarquons que le graphique forme un triangle inférieur. Cette formation est logique puisque nous ne pouvons pas être dédommagé plus que notre couverture d'assurance.


## Variable *primaryResidence*

```{r, echo=F}
ggplot(data, aes(x = primaryResidence, y = log(totalAmount), col = primaryResidence))+
  geom_boxplot()+
  theme_minimal()+
  labs( title = "Montant de la réclamation en fonction de primaryResidence" ,x = "Le bâtiment est une résidence primaire",y = "Montant total (échelle log)")+
  theme(legend.position = "none")
```


```{r, echo = F}
## Moyenne, ecartype, mediane, min , max

df <- data.frame(rbind(
  "Résidence primaire" = c(min(data$totalAmount[data$primaryResidence == 1]),
                  max(data$totalAmount[data$primaryResidence == 1]), 
                  median(data$totalAmount[data$primaryResidence == 1]),
                  mean(data$totalAmount[data$primaryResidence == 1]),
                  sd(data$totalAmount[data$primaryResidence == 1])),
  
  "Ne l'est pas"  = c(min(data$totalAmount[data$primaryResidence == 0]),
            max(data$totalAmount[data$primaryResidence == 0]),
            median(data$totalAmount[data$primaryResidence == 0]),
            mean(data$totalAmount[data$primaryResidence == 0]),
            sd(data$totalAmount[data$primaryResidence == 0]))
  ))
  


colnames(df) <- c("Min", "Max", "Médiane", "Moyenne", "Écart-type")

knitr::kable(df,caption = "Statistiques sur totalAmount selon primaryResidence")
```

Cette variable indique si le bâtiment assuré est la résidence primaire du client en prenant la valeur 1, dans le cas contraire 0.

En regardant le graphique et le table, il est évident que les réclamation sont plus importantes pour les résidences primaires.


\newpage
# Conclusion

En conclusion, on s’intéresse au montant des réclamations à la suite d’inondations dans l’état de la Californie, aux États-Unis. Cette première partie du rapport a consisté à sélectionner et à traiter les variables significatives pour notre problème : en retirant les variables non significatives, en traitant les données manquantes et en regroupant des variables & obervations. Au départ, on avait 41 variables avec environ 50 000 observations, à la suite de l’analyse et du traitement des données on a maintenant 13 variables avec environ 10 000 observations qui vont nous permettre de résoudre le problème. Pour ce faire, un modèle linéaire généralisé Gamma ou une régression linéaire multiple pourraient être utilisés.

\newpage
# Bibliographie

The Federal Emergency Management Agency (2023). FIMA NFIP Redacted Claims - v1.

Récupéré de https://www.fema.gov/openfema-data-page/fima-nfip-redacted-claims-v1


\newpage
# Annexe

Source : FEMA
 
Lien : https://www.fema.gov/openfema-data-page/fima-nfip-redacted-claims-v1
 
Description : Base de données de réclamations d'assurance faites, par contrat, à la suite d'inondations aux États-Unis. Puisque le jeux de données est trop volumineux, on utilise un subset de l'état de Californie.
 
Taille du jeu de données : 50 000 observations, 30 variables

Variable réponse : Le montant total payé par réclamation en dollar USD. Pour ce faire, nous devons additionner amountPaidOnBuildingClaim, amountPaidOnContentsCaim et amountPaidOnIncreasedCostOfComplianceClaim

Exposition: _policyCount_ le nombre de polices au contrat

Variables explicatives :
 1. _primaryResidence_ : Boolean, Y si résidence principale, N sinon
 2. _dateOfLoss_ : Date, date à laquelle il y a eu l'infiltration d'eau
 3. _occupancyType_ : Catégorielle, indique l'utilisation et le type du bâtiment
 4. _totalBuildingInsuranceCoverage_ et _totalContentsInsuranceCoverage_ : Numérique, le montant de la couverture au contrat
 5. _longitude_ et _latitude_ : Spatiale, longitude et latitude du bâtiment assuré
 




