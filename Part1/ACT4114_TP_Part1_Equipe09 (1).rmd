---
output:
  pdf_document:
    includes:
      before_body: "TP-title.tex"
      in_header: "preamble-latex.tex"
---  
\centering  

\clearpage  
  
\tableofcontents   

\justify  
\clearpage  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

 <!-- https://www.fema.gov/openfema-data-page/fima-nfip-redacted-claims-v1 -->
 
```{r paquetages, message=FALSE, eval=TRUE, include=FALSE, echo = FALSE}
### Liste des paquetages
liste.paquetage <- c("ggplot2", "maps", "mice", "graphics", "gridExtra")

### On installe les paquetages de la liste qu'on a pas déjà
inst <- liste.paquetage %in% installed.packages()
if(length(liste.paquetage[!inst]) > 0) install.packages(liste.paquetage[!inst])

lapply(liste.paquetage, require, character.only = TRUE)
library(ggplot2)
library(maps)
library(mice)
library(graphics)
library(gridExtra) 
```

```{r data import, echo = F}
data.raw <- read.csv("Flood_California.csv")
```

# Introduction

# Premier taitement des variables

## Sélection des variables

```{r data setup 1, echo = F}
## Retirer les variables inutiles
data.rm <- data.raw[, c(1, 3, 4, 5, 6, 13, 14, 15, 16, 21, 25, 27, 28, 33, 39, 41)]
data <- data.raw[, -c(1, 3, 4, 5, 6, 13, 14, 15, 16, 21, 25, 27, 28, 33, 39, 41)]
```

La première étape du travail a consisté à réduire la dimension du jeu de données. En effet, celui-ci est constitué de 41 variables, dont une bonne partie n'étant pas utiles dans le contecte de l'analyse des montants de réclamation. 

Sans effectuer aucune analyse statistique, nous avons jugé adéquat de retirer plusieurs variables du modèle, notamment, toutes les variables contenant beaucoup de valeurs manquantes, comme baseFloodElevation, basementEnclosureCrawlspace, elevationCertificateIndicator, elevationDifference, rateMethod et lowestAdjacentGrade. Ces variables sont aussi toutes issues de l'évaluation de quelques uns des bâtiments assurés, alors que plusieurs autres variables telles que numberOfFloorsInTheInsuredBuilding, originalConstructionDate ou encore lowestFloorElevation  auront un impact probablement plus marqué sur le modèle sans devoir nécessiter un travail ardu et approximatif d'estimation d'une grande quantité de données manquantes.

Nous avons aussi pris la décision d'enlever les variables temporelles à l'exception de la date de construction du bâtiment (originalConstructionDate) et la date du sinistre (dateOfLoss), puisqu'elles sont les seules variables temporelles pertinentes à notre analyse.


## Sélection des observations

Les sujets d'intérêts sont, pour se remémoriser, les polices d'assurances couvrant le risque d'inondation pour des bâtiments de l'État de la Californie. Il est donc important de s'assurer que les données proviennent uniquement de la Californie. On peut effectuer cette sélection grâce aux données de coordonnées (latitude et logitude) ainsi qu'avec les code de comtés disponibles dans le jeu de données. 

```{r USA map 1, message=FALSE, echo = F, warning=F}
## Carte des états-unis contanant toutes les données
mapUSA <- borders(database = "state", 
                  colour="gray50", fill="white")
ggplot(data = data, aes(x = longitude, y = latitude)) +
    mapUSA + geom_point(alpha = .4)
```
Grâce à cette carte, on peut facilement voir que certaines données ne sont visiblement pas situées en Californie. Ces observations sont retirées du jeu de données.

```{r Non-californian removal, echo = F}
# Retirer les lignes n'étant pas localisées en Californie
data <- data[!is.na(data$longitude),]
data <- data[data$longitude <= -110,]
```

Ensuite, en observant les codes de comtés des observations restantes, on peut réaliser que trois observations arborent le code "32031", qui appartient au comté de Washoe au Nevada. Ces trois données sont donc retirées du jeu de données.

```{r 32031 removal, echo = F}
# Retirer les lignes n'étant pas localisées en Californie
data <- data[data$countyCode != 32031,]
```

Voici à quoi ressemble la distribution des données restantes sur la carte de la Californie.

```{r geolocalisation, echo = T, warning=F}
mapCalifornia <- borders(database = "county", region = "california",
                  colour="gray50", fill="white")
ggplot(data = data, aes(x = longitude, y = latitude )) +
    mapCalifornia + geom_point(alpha = .4)  
```

## Imputation des données manquantes

Le jeu de données comporte plusieurs données manquantes réparties dans multiples variables explicatives. Explorons le patron de non réponse.

```{r initial md pattern, echo = F}
x <- md.pattern(data, rotate.names = T)
```
Attaquons la variable communityRatingDiscount en premier. En effet, celle-ci indique le niveau auquel la police d'assurance a droit à un rabais sur sa prime en fonction de de la zone d'inondation dans laquelle le bâtiment se retouve. La cote est sur une échelle de 1 à 10, du plus gros rabais pour la classe 1 à l'absence de rabais. La façon la plus intuitive que nous avons pu trouver de gérer les données manquante est de leur attribuer arbitrairement la classe 10, puisque selon l'organisme qui publie ces données, les données manquantes ne participent tout simplement pas au programme de primes.

```{r communityRatingDiscount, echo = F}
# Attribution de la classe 10 aux données manquantes de la variable communityRatingSystemDiscount (Les valeurs manquantes sont dans des zones qui ne participent pas au système de rabais, et la classe 10 indique les zones n'ayant pas droit à un rabais.)
data$communityRatingSystemDiscount[is.na(data$communityRatingSystemDiscount)] <- 10
```

Ensuite, la variable du nombre d'étages du bâtiment (variable numberOfFloorsInTheInsuredBuilding) arborait un certain nombre de données manquantes pouvant être imputées. Nous avons commencé par reclassifier cette la  du type d'occupartion du bâtiment (occupancyType) en trois classes plus intuitives selon les descriptions des 14 classes offertes par le publicateur des données. Une de ces 14 classes n'avait aucune description, nous l'avons attribué à la classe ayant la proportion du nombre d'étages la plus semblable, qui est la classe 2.

Niveau 1: Résidences familiales
Niveau 2: Copropriétés résidentielles
Niveau 3: Non-résidentiel

En effet, nous avons identifié la variable du type d'occupation intuitivement comme une variable intimement corrélée avec le nombre d'étages du bâtiment, car elle donnc des indices sur la nature du bâtiment. Elle servira donc à l'imputation des données du nombre d'étages.

Nous avons donc imputé les données à l'aide d'un modèle accordant le nombre d'étages aléatoirement en fonction de la distribution du nombre d'étages à l'intérieur d'une même classe d'occupation du bâtiment.

```{r occupancyType, echo = F}
# Reclassifiaction de la variable occupancyType
data$occupancyType <- as.factor(data$occupancyType)
levels(data$occupancyType) <- c("1", "2", "2", "3", "1", "1", "2", "2", "1", "2", "2", "3", "3", "3")

# Éliminaion des données manquant la variable occupancyType
data <- data[-which(is.na(data$occupancyType)),]

# Imputation des données manquantes de la variable numberOfFloorsInTheInsuredBuilding de facon aléatoire selon la proportion de la variable occupancyType de type 1

prop.occ1 <- cumsum(prop.table(table(data$numberOfFloorsInTheInsuredBuilding[which(data$occupancyType == 1)])))

imp.occ1 <- data$numberOfFloorsInTheInsuredBuilding[which(is.na(data$numberOfFloorsInTheInsuredBuilding))]
set.seed(6969)
RNG <- runif(length(imp.occ1))
for(i in 1:length(imp.occ1)){
  if(RNG[1] <= prop.occ1[1])
    imp.occ1[i] <- 1
if(RNG[i] > prop.occ1[1] & RNG[i] <= prop.occ1[2])
    imp.occ1[i] <- 2
  if(RNG[i] > prop.occ1[2] & RNG[i] <= prop.occ1[3])
    imp.occ1[i] <- 3
if(RNG[i] > prop.occ1[3] & RNG[i] <= prop.occ1[4])
    imp.occ1[i] <- 4
  if(RNG[i] > prop.occ1[4] & RNG[i] <= prop.occ1[5])
    imp.occ1[i] <- 5
  if(RNG[i] > prop.occ1[5])
    imp.occ1[i] <- 6
}

data$numberOfFloorsInTheInsuredBuilding[which(is.na(data$numberOfFloorsInTheInsuredBuilding))] <- imp.occ1
```

La dernière variable à imputer est l'indicateur du bâtiment étant un condo ou non. On utilise tout simplement notre variable du type d'occupation du bâtiment; si l'observation est dans la catégorie 2, on lui impute une valeur de "1" et une valeur de "0" dans le cas échéant.

```{r condoz, echo = F}
#Gestion des donnees manquantes de la variables condoIndicator

condoz <- numeric(length(data$condominiumIndicator))
for(i in 1:length(condoz)) {
  if (data$condominiumIndicator[i] == "N")
    condoz[i] <- 0
  if (data$condominiumIndicator[i] == "A" |
      data$condominiumIndicator[i] == "L" |
      data$condominiumIndicator[i] == "U" |
      data$condominiumIndicator[i] == "H")
    condoz[i] <- 1
  if (data$condominiumIndicator[i] == "")
    condoz[i] <- NA
}

data$condominiumIndicator <- condoz

xdf <- data[which(is.na(data$condominiumIndicator)), ]

xdg <- numeric(nrow(xdf))
for(i in 1:nrow(xdf)){
  if(xdf$occupancyType[i] == "2")
    xdg[i] <- 1
  else
    xdg[i] <- 0
}
data$condominiumIndicator[which(is.na(data$condominiumIndicator))] <- xdg
data$condominiumIndicator <- as.factor(data$condominiumIndicator)

```

Observons maintenant à nouveau notre patron de non réponse. 

```{r final md pattern, echo = F}
x <- md.pattern(data, rotate.names = T)
```

On remarque que les données manquantes restantes se retrouvent dans les trois variables contenant les montants de réclamation. Nous gèrerons ceci dans la prochaine section. 

## Création de la nouvelle variable réponse

Dans le jeu de données se retrouvent trois colonnes contenant des informations sur les montants de prestations payés en lien avec le bâtiment (amountPaidOnBuildingClaim), les biens (amountPaidOnContentsClaim) et l'augmentation des coûts en lien avec la conformité (amountPaidOnIncreasedCostOfComplianceClaim). 

On suppose dans ce cas que les données manquantes peuvent tout simplement se faire attribuer la valeur de 0, indiquant l'absence de paiement dans cette catégorie. Ensuite, nous combinons ces trois variables en créant une nouvelle variable du paiement de prestation total versé au détenteur de police. Celle-ci sera la variable réponse du modèle.

```{r total amount paid, echo = F}
# Combiner les variables réponses (totalAmount)
data$amountPaidOnBuildingClaim[is.na(data$amountPaidOnBuildingClaim)] <- 0
data$amountPaidOnBuildingClaim <-
  abs(data$amountPaidOnBuildingClaim)
data$amountPaidOnContentsClaim[is.na(data$amountPaidOnContentsClaim)] <-0
data$amountPaidOnContentsClaim <-
  abs(data$amountPaidOnContentsClaim)
data$amountPaidOnIncreasedCostOfComplianceClaim[is.na(data$amountPaidOnIncreasedCostOfComplianceClaim)] <- 0
data$amountPaidOnIncreasedCostOfComplianceClaim <-
  abs(data$amountPaidOnIncreasedCostOfComplianceClaim)
data$totalAmount <- apply(data[, 17:19], 1, sum)
data <- data[, -c(17, 18, 19)]
```


```{r final data setup, echo = F}
# Imputation par régression linéaire des codes de régions (countyCode)
mod.county <- lm(countyCode ~ latitude + longitude, data = data)
pred.county <- predict(mod.county, newdata = data[is.na(data$countyCode),], type = "response")
data$countyCode[is.na(data$countyCode)] <- pred.county

# Changement du type de variable pour les dates
data$dateOfLoss <- as.Date(data$dateOfLoss)

#sum(format(data$dateOfLoss, "%Y") != data$yearOfLoss)
# La variable YearofLoss peut être summprimée
data <- subset(data, select = -c(yearOfLoss))
```


# Analyse exploratoire des données

## Transformation des variables

```{r, echo=F}
# Transformations des variables en classes appropriées

data$agricultureStructureIndicator <- factor(data$agricultureStructureIndicator)

data$communityRatingSystemDiscount <- factor(data$communityRatingSystemDiscount)

data$elevatedBuildingIndicator <- factor(data$elevatedBuildingIndicator)

data$houseWorship <- factor(data$houseWorship)

data$locationOfContents <- factor(data$locationOfContents)

data$numberOfFloorsInTheInsuredBuilding <- factor(data$numberOfFloorsInTheInsuredBuilding)

data$nonProfitIndicator <- factor(data$nonProfitIndicator)

data$occupancyType <- factor(data$occupancyType)

data$smallBusinessIndicatorBuilding <- factor(data$smallBusinessIndicatorBuilding)

data$primaryResidence <- factor(data$primaryResidence)

# On est interessé au montant de la réclamation s'il y a 
data <- subset(data, data$totalAmount > 1 )
```

```{r, echo = F}
p1 <- ggplot(data, aes(x = agricultureStructureIndicator, fill = agricultureStructureIndicator))+
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0.25, size = 2)+
  labs(y = "Quantité", x = "Est une structure agricole")+
  theme(legend.position = "none")   

p2 <- ggplot(data, aes(x = houseWorship, fill = houseWorship))+  
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0.25, size = 2)+
  labs(y = "Quantité", x = "Est une structure religieuse")+
  theme(legend.position = "none")

p3 <- ggplot(data, aes(x = smallBusinessIndicatorBuilding, fill = smallBusinessIndicatorBuilding))+
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0.25,size = 2)+
  labs(y = "Quantité", x = "Est une petite entreprise")+
  theme(legend.position = "none")

p4 <- ggplot(data, aes(x = nonProfitIndicator, fill = nonProfitIndicator))+
  geom_bar()+
  theme_minimal()+
  geom_text(stat='count', aes(label=after_stat(count)), vjust=-0.25, size = 2)+
  labs(y = "Quantité", x = "Est un organisme à non-profit")+
  theme(legend.position = "none")


grid.arrange(p1, p2, p3, p4 , ncol = 3)

data <- subset(data, select = -c(agricultureStructureIndicator, houseWorship, smallBusinessIndicatorBuilding, nonProfitIndicator))
```


Tel qu'on peut le voir dans les graphiques précédants, les quatres variables indicatices (smallBusinessIndicatorBuilding, agricultureStructureIndicator, houseWorship et nonProfitIndicator) sont trop peu fréquentes pour être significatives, elles seront donc élminées.


```{r, echo=F}
p1 <- ggplot(data, aes(x = communityRatingSystemDiscount, y = log(totalAmount), col = communityRatingSystemDiscount ))+
  geom_boxplot()+
  labs(title = "Avant le regroupement",y = "Montant total (échelle log)", x = "Type de rabais", col = "")+
  theme_minimal()+
  coord_flip()+
  theme(legend.position = "none")


levels(data$communityRatingSystemDiscount) <- c("4","4","3","3","2","2","2","2","1")

p2 <- ggplot(data, aes(x = communityRatingSystemDiscount, y = log(totalAmount), col = communityRatingSystemDiscount ))+
  geom_boxplot()+
  labs(title = "Après le regroupement",y = "Montant total (échelle log)", x = "Type de rabais", col = "")+
  theme_minimal()+
  coord_flip()+
  theme(legend.position = "none")

grid.arrange(p1, p2, ncol = 1)
```

Pour la variable communityRatingSystemDiscount, il y a un trop grand nombre de catégories. Pour cette raison, elles sont réeunies en quatres catégories de crédit:

* Niveau 1 : Aucun
* Niveau 2 : 20% - 5%
* Niveau 3 : 35% - 25%
* Niveau 4 : Plus de 40%

Pour faciliter la visualisation une transformation log est effectuée sur le montant total, cette échelle sera utilisée pour de futurs graphiques.

```{r, echo=F}
p1 <- ggplot(data, aes(x = locationOfContents))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)), nudge_y =250, size = 4)+
  theme_minimal()+
  labs(title = "Avant le regroupement",y = "Quantité", x = "Location du contenu")+ coord_flip()
  
p2 <- ggplot(data, aes(x = locationOfContents, y = log(totalAmount), col = locationOfContents))+
  geom_boxplot()+
  theme_minimal()+
  labs(y = "Montant total (échelle log)", x = "Location du contenu")+
  coord_flip()+
  theme(legend.position = "none")


grid.arrange(p1, p2, ncol = 1)
```

On remarque pour la variable locationOfContents, qu'il y a plusieurs catégories ne comportant qu'un faible nombre d'observations. Certaines seront donc combinées pour former les nouvelles catégories indiquant la location des objets endomagés dans le bâtiment assuré:

* Niveau 1 : Sous-sol
* Niveau 2 : Premier étage seulement
* Niveau 3 : Premier étage et plus



```{r, echo = F}
levels(data$locationOfContents) <- c("1","1","1","2","3","3","2","1")

p3 <- ggplot(data, aes(x = locationOfContents))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)),nudge_y = 250, size = 4)+
  theme_minimal()+
  labs(title = "Après le regroupement",y = "Quantité", x = "Location du contenu")+
  theme(legend.position = "none")+ 
  coord_flip()
  
p4 <- ggplot(data, aes(x = locationOfContents, y = log(totalAmount), col = locationOfContents))+
  geom_boxplot()+
  theme_minimal()+
  labs(y = "Montant total (échelle log)", x = "Location du contenu")+
  coord_flip()+
  theme(legend.position = "none")

grid.arrange(p3, p4, ncol = 1)
```
```{r, echo=F}
p1 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)), nudge_y =250, size = 4)+
  theme_minimal()+
  labs(title = "Avant le regroupement",y = "Quantité", x = "Nombre d'étages")+ coord_flip()
  
p2 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding, y = log(totalAmount), col = numberOfFloorsInTheInsuredBuilding))+
  geom_boxplot()+
  theme_minimal()+
  labs(y = "Montant total (échelle log)", x = "Nombre d'étages")+
  coord_flip()+
  theme(legend.position = "none")


grid.arrange(p1, p2, ncol = 1)
```
```{r, echo = F}
levels(data$numberOfFloorsInTheInsuredBuilding) <- c("1","2","3","2","1","3")

p3 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding))+
  geom_bar()+
  geom_text(stat='count', aes(label=after_stat(count)),nudge_y = 250, size = 4)+
  theme_minimal()+
  labs(title = "Après le regroupement",y = "Quantité", x = "Nombre d'étages")+
  theme(legend.position = "none")+ 
  coord_flip()
  
p4 <- ggplot(data, aes(x = numberOfFloorsInTheInsuredBuilding, y = log(totalAmount), col = numberOfFloorsInTheInsuredBuilding))+
  geom_boxplot()+
  theme_minimal()+
  labs(y = "Montant total (échelle log)", x = "Nombre d'étages")+
  coord_flip()+
  theme(legend.position = "none")

grid.arrange(p3, p4, ncol = 1)
```

* Niveau 1 : 1 étage
* Niveau 2 : 2 étages
* Niveau 3 : 3 étages et plus


## Explication des variables

* `condominiumIndicator` : Variable indicatrice, 1 si l'habitation est un condominium, 0 sinon.

* `policycount` : Le nombre de polices actives pour l'assuré.

* `county code` : Représente le code du comté.

* `communityRatingSystemDiscount` : Variable catégorielle indiquant le pourcentage de rabais accordé lors de la tarrification. (Plus de 40%, 35% - 25%, 20% - 5%, Aucun)

* `dateOfLoss` : La date où s'est produit l'infiltration d'eau dans le bâtiment.

* `elevatedBuildingIndicator` : Variable indicatrice, 1 si le bâtiment est élevé, c'est-à-dire, au dessus du nieveau ddu sol, 0 sinon.

* `latitude` et `longitude` : Position géoographique du bâtiment assuré, à une décimale près.

* `locationOfContents` : Variable catégoritielle indiquant où se trouve le contenu du bâtiment qui a été endomagé.

* `lowersFlorElevation` : La hauteur du plus bas étage de l'habitation, en pieds.

```{r, echo = F, warning = F}
data.x <- subset(data, data$lowestFloorElevation < 2000)
data.x <- subset(data.x,data$totalAmount < 400000)

ggplot(data.x, aes(x = lowestFloorElevation, y = totalAmount))+
  geom_point(alpha = 0.4)+
  theme_minimal()+
  labs(x = "La hauteur du plus bas étage (Pieds)", y = "Montant total" )
  
```

* `numberOfFloorsInTheInsuredBuilding` : Variable catécorielle de trois niveaux indiquant le nombre d'étages de la propriété. (1 étage, 2 étages, 3 étages ou plus)

* `occupancyType`




\newpage
# Conclusion


\newpage
# Bibliographie


]\newpage
# Annexe




